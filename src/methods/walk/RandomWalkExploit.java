/**
 * 
 */
package methods.walk;

import libs.*;
import methods.GSInput;
import methods.GoldenSection;

/**
 * @author iskoulis
 *
 */
public class RandomWalkExploit extends RandomWalk {
	
	protected static long steps = 1;;

	public static Result run(Input in) {
		RWEInput input = (RWEInput) in;
		double x0[] = new double[in.dim];
		for (int i = 0; i < in.dim; i++) {
			double range = in.range.max[i] - in.range.min[i];
			x0[i] = Math.random()*range + in.range.min[i];;
		}
		Point pRand = null, p = new Point(x0);
		double f = input.func.f(p);
		try{
			do{
				pRand = rand(in.dim);
				double step = bestStep(p, pRand, input, input.gsSteps);
				p = Point.add(p, pRand.mull(step));
				f = in.func.f(p); steps++;
			} while (steps < in.steps);
		}catch(Exception e){
			e.printStackTrace();
			return null;
		}
		Result res = new Result(p, f, steps);
		return res;
	}
	
	public static Result run_old(Input in) {
		RWInput input = (RWInput) in;
		double x0[] = new double[in.dim];
		for (int i = 0; i < in.dim; i++) {
			double range = in.range.max[i] - in.range.min[i];
			x0[i] = Math.random()*range + in.range.min[i];
		}
		Point pRand = null, pNew, pOld = new Point(x0);
		double fNew, fOld = in.func.f(pOld);
		long steps = 1;
		double iter = 0;
		boolean newRand = true;
		try{
			do{
				if (newRand) pRand = rand(in.dim);
				pNew = Point.add(pOld, pRand.mull(input.l));
				fNew = input.func.f(pNew); steps++;
				if (fNew >= fOld) {
					iter++;
					if (iter >= input.iter) {
						input.l /= 2;
						if (input.l < input.lmin) {
							Result res = new Result(pOld, fOld, steps);
							return res;
						} else {
							iter = 0;
							newRand = false;
						}
					} else {
						newRand = true;
					}
				} else {
					fOld = fNew;
					pOld = pNew;
					iter = 0;
					newRand = true;
				}
			}while (steps < in.steps);
		}catch(Exception e){
			e.printStackTrace();
			return null;
		}
		Result res = new Result(pOld, fOld, steps);
		return res;
	}
	
	protected static double bestStep(Point start, Point dir, Input in, long gsSteps) throws Exception {
		double l = Double.POSITIVE_INFINITY;
		for (int i = 0; i < in.dim; i++) {
			double low = in.range.min[i] - start.p[i];
			double hi = in.range.max[i] - start.p[i];
			if (dir.p[i] != 0) {
				double tmp;
				if (dir.p[i] < 0) {
					tmp = low/dir.p[i];
					if (l > tmp) {
						l = tmp;
					}
				} else {
					tmp = hi/dir.p[i];
					if (l > tmp) {
						l = tmp;
					}
				}
			}
		}
//		if (l > 1) l = in.steps/steps;
		if (l > 1) l = 1;
		Point end = Point.add(start, dir.mull(l));
		Range range = new Range(start.p, end.p);
		
		Input i = new GSInput(in.func, range, gsSteps, Math.pow(10, -6), dir);
		Result res = GoldenSection.run(i);
		steps += res.getSteps();
		return start.dist(res.getRes());
	}
}
